!use crate::absyntax::*;
!use crate::absyntax::Construct::*;
!use crate::absyntax::Direction::*;
!use rustlr::{LBox, makelbox};

lifetime 'src_lt
absyntype Construct<'src_lt>
terminal ID
terminal # ( ) , ;
terminal LBR RBR
terminal module endmodule input output wire
terminal xor and or
nonterminal Module
nonterminal ModuleNonAnsiHeader
nonterminal ListOfPorts
nonterminal ListOfPortsTail
nonterminal Port
topsym Module

Module ==> ModuleNonAnsiHeader:@Header(h)@ endmodule {
    Module(ModuleDec{ name:h.name,
                      ports:h.ports })
    } <==
ModuleNonAnsiHeader ==> module ID:@Id(i)@ ListOfPorts:@Ports(p)@ ; {
    Header(HeaderDec{ name:i,
                      ports:p, })
    } <==
ListOfPorts ==> ( Port:@Port(p)@ ListOfPortsTail:@Ports(mut l)@ ) {
    l.push(parser.lb(p));
    Ports(l)
    } <==
ListOfPortsTail --> { Ports(Vec::new()) }
ListOfPortsTail ==> , Port:@Port(p)@ ListOfPortsTail:@Ports(mut l)@ {
    l.push(parser.lb(p));
    Ports(l)
    } <==
Port ==> ID:@Id(i)@ {
    Port(PortDec{ name:i,
                   direction: Direction::Unspecified})
    } <==

lexname LBR {
lexname RBR }
# lexvalue BOOL Alphanum("true") Exp(Bool(true))
# lexvalue BOOL Alphanum("false") Exp(Bool(false))
lexvalue ID Alphanum(x) Id(x)
# lexvalue INTEGER Num(n) Exp(Int(n as i32))
# lexvalue STRING Strlit(s) Exp(Strlit(s))